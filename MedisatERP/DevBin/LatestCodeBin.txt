

### Conclusion:
Claims are key-value pairs that store information about the user (such as their role, permissions, or custom attributes). 
These claims are then used to **authorize** users to perform certain actions in your 
system, making claims a crucial part of your application's **security** and **access control**.

[HttpPost]
        public async Task<IActionResult> Post([FromBody] AspNetUser userInput)
        {
            try
            {
                // Log the content of the incoming request for debugging
                if (userInput == null)
                {
                    Console.WriteLine("Received user input: null");
                    return BadRequest(new { message = "User input cannot be empty." });
                }

                var userInputJson = JsonConvert.SerializeObject(userInput, Formatting.Indented);
                Console.WriteLine($"Received user input: {userInputJson}");

                // List of restricted roles (e.g., "System Administrator")
                var restrictedRoles = new List<string> { "System Administrator" };

                // ******To do ********** //
                // if account is just being created and role is restricted roles add account lockup enable

                // Handle roles if provided in the user input
                if (userInput.Roles != null && userInput.Roles.Any())
                {
                    Console.WriteLine("Processing roles...");
                    foreach (var roleObject in userInput.Roles)
                    {
                        if (roleObject == null || roleObject.Id == null)
                        {
                            Console.WriteLine($"Invalid Role object: {roleObject}");
                            return BadRequest(new { message = "Invalid Role object." });
                        }

                        var roleId = roleObject.Id;
                        Console.WriteLine($"Checking role with ID '{roleId}'...");

                        var roleFromDb = await _context.AspNetRoles
                            .FirstOrDefaultAsync(r => r.Id == roleId);

                        if (roleFromDb == null)
                        {
                            Console.WriteLine($"Role with ID '{roleId}' not found.");
                            return NotFound(new { message = $"Role with ID '{roleId}' not found." });
                        }

                        if (userInput.CompanyId.HasValue && restrictedRoles.Contains(roleFromDb.Name))
                        {
                            Console.WriteLine($"User has a CompanyId and role '{roleFromDb.Name}' is restricted. Terminating.");
                            return BadRequest(new { message = "Role NOT applicable for user!" });
                        }
                    }
                }
                else
                {
                    Console.WriteLine("No roles provided, skipping role logic.");
                }

                // Create an IdentityUser instance for UserManager only after role checks
                Console.WriteLine("Attempting to find user by ID...");
                var identityUser = await _userManager.FindByIdAsync(userInput.Id.ToString());
                if (identityUser == null)
                {
                    Console.WriteLine("User not found.");
                    return NotFound(new { message = "User not found." });
                }

                // Update the user properties
                Console.WriteLine("Updating user properties...");
                identityUser.UserName = userInput.UserName;
                identityUser.Email = userInput.Email;
                identityUser.PhoneNumber = userInput.PhoneNumber;

                // Password hashing, update only if provided
                if (!string.IsNullOrEmpty(userInput.PasswordHash))
                {
                    Console.WriteLine("Hashing password...");
                    var passwordHasher = new PasswordHasher<IdentityUser>();
                    identityUser.PasswordHash = passwordHasher.HashPassword(identityUser, userInput.PasswordHash);
                }

                // Update the user in the database
                Console.WriteLine("Attempting to update user in the database...");
                var updateResult = await _userManager.UpdateAsync(identityUser);
                if (!updateResult.Succeeded)
                {
                    Console.WriteLine($"User update failed: {string.Join(", ", updateResult.Errors.Select(e => e.Description))}");
                    return BadRequest(new { message = "Failed to update user.", errors = updateResult.Errors });
                }
                Console.WriteLine("User updated successfully.");

                // Handle roles after user is updated (only if roles are provided)
                if (userInput.Roles != null && userInput.Roles.Any())
                {
                    Console.WriteLine("Assigning roles...");
                    foreach (var roleObject in userInput.Roles)
                    {
                        var roleId = roleObject.Id;

                        var roleFromDb = await _context.AspNetRoles
                            .FirstOrDefaultAsync(r => r.Id == roleId);

                        if (roleFromDb != null)
                        {
                            var roleName = roleFromDb.Name;

                            if (userInput.CompanyId.HasValue && restrictedRoles.Contains(roleName))
                            {
                                Console.WriteLine($"User has a CompanyId and role '{roleName}' is restricted. Skipping assignment.");
                                continue;
                            }

                            var addRoleResult = await _userManager.AddToRoleAsync(identityUser, roleName);

                            if (!addRoleResult.Succeeded)
                            {
                                Console.WriteLine($"Role assignment failed for '{roleName}': {string.Join(", ", addRoleResult.Errors.Select(e => e.Description))}");
                                await _userManager.DeleteAsync(identityUser); // Optionally delete if role assignment fails
                                Console.WriteLine("User deleted due to role assignment failure.");
                                return BadRequest(new { message = "Failed to assign role." });
                            }

                            Console.WriteLine($"Role '{roleName}' assigned successfully.");
                        }
                    }
                }

                // Handle the company ID if provided
                if (userInput.CompanyId.HasValue)
                {
                    Console.WriteLine("Assigning CompanyId...");
                    var userFromDb = await _context.AspNetUsers
                        .FirstOrDefaultAsync(u => u.UserName == identityUser.UserName);

                    if (userFromDb != null)
                    {
                        userFromDb.CompanyId = userInput.CompanyId;
                        await _context.SaveChangesAsync();
                        Console.WriteLine($"Company Id '{userFromDb.CompanyId}' assigned successfully.");
                    }
                }



                return Json(new { success = true, Id = identityUser.Id, message = "Profile updated successfully." });

            }
            catch (Exception ex)
            {
                // Log the exception message and stack trace for debugging purposes
                Console.WriteLine($"An error occurred: {ex.Message}");
                Console.WriteLine($"Stack trace: {ex.StackTrace}");
                return StatusCode(500, new { message = "An internal server error occurred.", error = ex.Message });
            }
        }



        You're correct that there are several other events in DevExtreme's DataGrid, such as `onEditingPrepared`, `onEditingPreparing`, `onEditingCanceled`, and `onEditingCanceling`, which may be more appropriate depending on the specific behavior you want to achieve.

### Let's clarify the difference between `onEditingStart` and these other events:

1. **`onEditingStart`**:  
   - This event is triggered when the user starts editing a row. This is an ideal place to set up initial data or perform some validation before editing starts. 
   - However, it may not be the best place to modify data dynamically like `NormalizedUserName` or `NormalizedEmail`, since the user is already interacting with the grid.
   
2. **`onEditingPrepared`**:  
   - This event is triggered after the editor for a particular cell is prepared. This might be a good place to adjust the value of `NormalizedUserName` or `NormalizedEmail` dynamically as the user interacts with the editor, but not yet after the user submits the edit.

3. **`onEditingPreparing`**:  
   - This event occurs before the row enters the edit mode, allowing you to modify or prevent the edit action. It can be used for validating or altering the initial values right before the editor opens, but it’s not typically used for dynamically adjusting data as in your scenario.

4. **`onEditingCanceled` / `onEditingCanceling`**:
   - These events are triggered when the editing operation is canceled, either because the user pressed cancel or the operation was programmatically canceled. They are not relevant for your use case, as they happen after the user exits editing.

### So, what's the right choice here?

**`onEditingPrepared`** might be the most appropriate event in this scenario to dynamically update the `NormalizedUserName` and `NormalizedEmail` values as the user begins editing. This event fires after the editor is prepared, but before the user starts editing, which means you can modify the values before the editing process is fully activated.

### Updated Approach using `onEditingPrepared`:

```html
<script>
    // Update NormalizedUserName and NormalizedEmail when editing starts
    $("#gv_userList").dxDataGrid({
        onEditingPrepared: function (e) {
            // Ensure the NormalizedUserName is updated when UserName is changed
            if (e.column.dataField === "UserName" && e.value) {
                e.component.cellValue(e.rowIndex, "NormalizedUserName", e.value.toUpperCase());
            }
            // Ensure the NormalizedEmail is updated when Email is changed
            if (e.column.dataField === "Email" && e.value) {
                e.component.cellValue(e.rowIndex, "NormalizedEmail", e.value.toUpperCase());
            }
        }
    });
</script>
```

### Explanation of this approach:

- **`onEditingPrepared`**:
   - This event is fired right after the editor is initialized but before the user starts editing the cell. This is the perfect moment to manipulate or initialize any data before the user interacts with the grid.
   - We check if the column being edited is `UserName` or `Email`, and then we use `e.component.cellValue` to set the value for the corresponding `NormalizedUserName` or `NormalizedEmail` columns (which are hidden from the user).

### Why is this approach better?

- **Non-intrusive**: You don't have to rely on user actions to update the `NormalizedUserName` and `NormalizedEmail` values after they start editing. Instead, the values are updated right when the editor is ready.
- **Avoids unnecessary user interaction**: The user doesn't have to perform additional actions to ensure `NormalizedUserName` and `NormalizedEmail` are updated, which improves the user experience.

This should be a cleaner, more appropriate approach for updating these fields without involving the user directly in the process.


// Retrieve subscription logs associated with the user
                var subscriptionLogs = await _dbContext.SubscriptionLogs.Where(s => s.UserId == decodedUserId).ToListAsync();

                // Attach the logs to the user model
                user.SubscriptionLogs = subscriptionLogs;


.Lookup(lookup => lookup
.DataSource(ds => ds.Mvc()
.Controller("TreeListTasks")
.LoadAction("TaskEmployees")
.Key("ID")
)
.ValueExpr("ID")
.DisplayExpr("Name")
);




The issue you're encountering—getting a **bad request** due to 2FA being required—means that the `PasswordSignInAsync` method is detecting that the user has 2FA enabled but you're not handling the 2FA verification properly in your code.

When `PasswordSignInAsync` detects that the user has 2FA enabled, it returns a result indicating that the user needs to complete a 2FA check (typically `SignInResult.RequiresTwoFactor`). You need to catch this result and handle the 2FA process accordingly.

Here's a breakdown of what needs to be done:

1. **Detect the 2FA Requirement**: After attempting to sign in with `PasswordSignInAsync`, if 2FA is required, the result will indicate that, and you need to redirect the user to a 2FA verification page.

2. **Handle 2FA Verification**: If 2FA is enabled, you need to prompt the user for a 2FA code (either via email or SMS), and then verify that the code matches the one sent to the user.

3. **Return Response Based on 2FA**: If the 2FA verification is successful, proceed with the login process, otherwise return a failure message.

### Updated Code with 2FA Handling

Here's how you can modify your `LoginCheck` action to handle 2FA:

```csharp
[HttpGet]
public async Task<ActionResult> LoginCheck(string email, string password)
{
    // Log the start of the login attempt
    Console.WriteLine($"Login attempt started for email: {email}");

    // Find user by email
    var user = await _userManager.FindByEmailAsync(email);
    if (user == null)
    {
        // Log when the user is not found
        Console.WriteLine($"User not found for email: {email}");
        return BadRequest(new { success = false, mresponse = "User not found" });
    }

    // Log when the user is found
    Console.WriteLine($"User found for email: {email}");

    // Attempt login
    var result = await _signInManager.PasswordSignInAsync(user, password, isPersistent: false, lockoutOnFailure: false);

    if (result.Succeeded)
    {
        // Log successful login
        Console.WriteLine("Login successful.");

        // Check if the user needs 2FA verification
        if (await _userManager.GetTwoFactorEnabledAsync(user))
        {
            // If 2FA is required, check the user's preferred method (SMS or Email)
            var preferred2FAMethod = user.Preferred2FAMethod;

            // Send 2FA code based on preferred method
            if (preferred2FAMethod == "SMS")
            {
                var code = await _userManager.GenerateTwoFactorTokenAsync(user, "Phone");
                await _smsService.SendSmsAsync(user.PhoneNumber, code); // Implement SMS service
                Console.WriteLine("2FA code sent via SMS.");
            }
            else if (preferred2FAMethod == "Email")
            {
                var code = await _userManager.GenerateTwoFactorTokenAsync(user, "Email");
                await _emailService.SendEmailAsync(user.Email, "Your 2FA Code", code); // Implement Email service
                Console.WriteLine("2FA code sent via Email.");
            }

            // Return a response indicating the user should enter their 2FA code
            return Ok(new { success = true, mresponse = "2FA code sent", requires2FA = true });
        }

        // If no 2FA required, continue processing roles and redirect
        var roles = await _userManager.GetRolesAsync(user);

        var aspNetUser = await _dbContext.Set<AspNetUser>().FirstOrDefaultAsync(u => u.Email == email);

        if (roles.Contains("System Administrator"))
        {
            if (aspNetUser == null)
            {
                // Log when the user is not found in the custom table
                Console.WriteLine($"Custom user not found for email: {email}");
                return BadRequest(new { success = false, mresponse = "User not found." });
            }

            // Log the found AspNetUser
            Console.WriteLine($"Custom user found with CompanyId: {aspNetUser.Id}");

            var userId = aspNetUser.Id;

            if (userId != null)
            {
                // Encode the User Id using HashingHelper
                var encodedUserId = HashingHelper.EncodeString(userId);

                // Log the encoded CompanyId
                Console.WriteLine($"Encoded UserId: {encodedUserId}");

                // Construct the redirect URL
                var redirectUrl = $"/CoreSystem/SystemManager/Index/{encodedUserId}";

                // Return the response with the redirect URL
                return Ok(new { success = true, mresponse = "Login successful", redirectUrl });
            }
        }
        else if (roles.Contains("Company Administrator"))
        {
            if (aspNetUser == null)
            {
                // Log when the user is not found in the custom table
                Console.WriteLine($"Custom user not found for email: {email}");
                return BadRequest(new { success = false, mresponse = "User not found." });
            }

            // Log the found AspNetUser
            Console.WriteLine($"Custom user found with CompanyId: {aspNetUser.CompanyId}");

            var companyId = aspNetUser.CompanyId;

            if (companyId != null)
            {
                // Encode the CompanyId using HashingHelper
                var encodedCompanyId = HashingHelper.EncodeGuidID(companyId.Value);

                // Log the encoded CompanyId
                Console.WriteLine($"Encoded CompanyId: {encodedCompanyId}");

                // Construct the redirect URL
                var redirectUrl = $"/NutritionCompanySystem/NutritionSystem/Index/{encodedCompanyId}";

                // Return the response with the redirect URL
                return Ok(new { success = true, mresponse = "Login successful", redirectUrl });
            }
        }
        else
        {
            // Log when the user is neither a System Administrator nor a Company Administrator
            Console.WriteLine("User is neither a System Administrator nor a Company Administrator.");
            return Ok(new { success = true, mresponse = "Login successful" });
        }
    }

    // Log for failed login attempt
    Console.WriteLine("Invalid login attempt for email: " + email);
    return BadRequest(new { success = false, mresponse = "Invalid login attempt" });
}
```

### Key Changes:
1. **Checking if 2FA is enabled**: After a successful password sign-in, we check if the user has 2FA enabled using `await _userManager.GetTwoFactorEnabledAsync(user)`.
2. **Sending the 2FA code**: Based on the user's preferred 2FA method (SMS or email), we send the code using the appropriate service (SMS or email).
3. **Handling the 2FA Requirement**: If 2FA is enabled, we return a response indicating that the 2FA code has been sent and the user needs to provide it.
4. **Redirecting after successful login**: If no 2FA is required, the code proceeds to process roles and redirect the user to the appropriate page.

### Next Steps:
1. **2FA Code Verification**: You'll need an additional endpoint that verifies the 2FA code once the user enters it.
   
   For example:

   ```csharp
   [HttpPost]
   public async Task<IActionResult> Verify2FA(string email, string code)
   {
       var user = await _userManager.FindByEmailAsync(email);
       if (user == null)
       {
           return BadRequest(new { success = false, mresponse = "User not found" });
       }

       // Check if the user has 2FA enabled and verify the code
       var is2FACodeValid = await _userManager.VerifyTwoFactorTokenAsync(user, "Phone", code); // or "Email"
       if (is2FACodeValid)
       {
           await _signInManager.SignInAsync(user, isPersistent: false);
           return Ok(new { success = true, mresponse = "2FA successful, logged in." });
       }

       return BadRequest(new { success = false, mresponse = "Invalid 2FA code" });
   }
   ```

2. **User Interface**: You'll need to implement a UI where the user can input the 2FA code (sent via email or SMS) after login.

Sure! Let me clarify what a **claim** is and how it works with your `AspNetUserClaim` model. I'll also provide some **user scenarios** 
to help explain claims in a practical context.

### What is a Claim?
In ASP.NET Identity, a **claim** is essentially a piece of information about a user that is stored in a **key-value** pair. 
Claims are used to represent data that can help identify, authorize, or provide additional context about a user. 
They are typically stored and managed alongside the user's profile and are used for various security and business logic purposes.

A **claim** does not necessarily mean an **action** or an **event** (e.g., if a user tries to access unauthorized content). 
Instead, it is about storing data that can represent **attributes** of the user or their **permissions**. 
Claims are part of the user's identity and can be used to **authorize** access to resources, check if a user has specific roles, or manage certain aspects of 
the user’s behavior.

### Example of Claims in Your `AspNetUserClaim` Model:
Your model represents the claim with the following properties:

- `Id`: The primary key of the claim.
- `UserId`: A reference to the `AspNetUser` this claim belongs to (foreign key).
- `ClaimType`: The type of the claim (e.g., `"role"`, `"email"`, `"permission"`, etc.).
- `ClaimValue`: The value of the claim (e.g., `"admin"`, `"user@example.com"`, `"can_view_reports"`).

### Practical Scenarios for Claims

Let's go through some **user scenarios** to understand how claims are used in an application:

### 1. **User Role Claim**
- **Scenario:** 
  - Let's say you have an application where users can have different roles, like `Admin`, `Manager`, and `User`.
  - The role of a user determines what parts of the application they can access.

- **How Claims Work in This Scenario:**
  - When a user logs in, your system might create a claim for that user with the claim type `"role"` and the claim value `"Admin"` (or whatever role the user belongs to).
  - Example: 
    ```csharp
    user.AspNetUserClaims.Add(new AspNetUserClaim { ClaimType = "role", ClaimValue = "Admin" });
    ```
  - Now, when the application checks the user's claims (for authorization), it can check if the user has a claim of type `"role"` with the value `"Admin"`. If so, the user is authorized to access admin-specific content.

- **Example of Using the Claim in Code:**
  When checking if the user is authorized to perform an action, you might do something like this:

  ```csharp
  var userRoleClaim = user.AspNetUserClaims.FirstOrDefault(c => c.ClaimType == "role" && c.ClaimValue == "Admin");
  if (userRoleClaim != null)
  {
      // User is an Admin, allow access
  }
  else
  {
      // Deny access
  }
  ```

### 2. **Email Verified Claim**
- **Scenario:**
  - A user registers on the platform, and the system requires them to verify their email before they can access certain features.
  - The system can issue a claim indicating that the email has been verified.

- **How Claims Work in This Scenario:**
  - After the user verifies their email, the system adds a claim for the user with the claim type `"email_verified"` and a claim value of `"true"`.
  - Example: 
    ```csharp
    user.AspNetUserClaims.Add(new AspNetUserClaim { ClaimType = "email_verified", ClaimValue = "true" });
    ```
  - Now, when the system checks whether the user can access email-dependent features, it can check for the `"email_verified"` claim.

- **Example of Using the Claim in Code:**
  ```csharp
  var emailVerifiedClaim = user.AspNetUserClaims.FirstOrDefault(c => c.ClaimType == "email_verified" && c.ClaimValue == "true");
  if (emailVerifiedClaim != null)
  {
      // User's email is verified, grant access to email-dependent features
  }
  else
  {
      // Prompt user to verify their email first
  }
  ```

### 3. **Permissions or Custom Claims**
- **Scenario:**
  - A user might have custom permissions, like the ability to view reports or delete records.
  - These permissions can be stored as claims to determine whether the user is authorized to perform certain actions.

- **How Claims Work in This Scenario:**
  - Each user might have claims such as `"can_view_reports"`, `"can_delete_records"`, etc.
  - Example:
    ```csharp
    user.AspNetUserClaims.Add(new AspNetUserClaim { ClaimType = "can_view_reports", ClaimValue = "true" });
    user.AspNetUserClaims.Add(new AspNetUserClaim { ClaimType = "can_delete_records", ClaimValue = "false" });
    ```
  - Now, when the user attempts to perform a certain action (e.g., view reports), the system checks for the corresponding claim.

- **Example of Using the Claim in Code:**
  ```csharp
  var viewReportsClaim = user.AspNetUserClaims.FirstOrDefault(c => c.ClaimType == "can_view_reports" && c.ClaimValue == "true");
  if (viewReportsClaim != null)
  {
      // User can view reports, allow access
  }
  else
  {
      // Deny access
  }
  ```

### Summary of Claims:
- **Claims represent** user-specific information, like roles, permissions, email verification status, or custom attributes.
- **Claims are used for authorization**: When a user attempts to access certain functionality, the application checks their 
claims to see if they have the necessary permissions or roles to do so.
- **Claims are stored** in the database (e.g., in your `AspNetUserClaim` table), and can be used to enhance user security and application logic.
  
### Common Uses of Claims:
1. **Authorization**: Checking if a user has the right permissions or role to access certain parts of the application.
2. **Personalization**: Storing user preferences or information that can personalize their experience (e.g., preferred language).
3. **Two-Factor Authentication (2FA)**: Storing a claim for whether a user has enabled 2FA.
4. **Application Logic**: Custom attributes, like whether the user is a premium member or has access to a certain feature, 
can be stored as claims and used for controlling access.

### Example of Claims in Action:
- A **Premium Member** user could have a claim like:
  ```csharp
  user.AspNetUserClaims.Add(new AspNetUserClaim { ClaimType = "is_premium", ClaimValue = "true" });
  ```
- This claim could be checked every time the user tries to access premium features in the app:
  ```csharp
  var isPremium = user.AspNetUserClaims.FirstOrDefault(c => c.ClaimType == "is_premium" && c.ClaimValue == "true");
  if (isPremium != null)
  {
      // Allow access to premium features
  }
  else
  {
      // Deny access
  }
  ```

### Conclusion:
Claims are key-value pairs that store information about the user (such as their role, permissions, or custom attributes). 
These claims are then used to **authorize** users to perform certain actions in your 
system, making claims a crucial part of your application's **security** and **access control**.

[HttpPost]
        public async Task<IActionResult> Post([FromBody] AspNetUser userInput)
        {
            try
            {
                // Log the content of the incoming request for debugging
                if (userInput == null)
                {
                    Console.WriteLine("Received user input: null");
                    return BadRequest(new { message = "User input cannot be empty." });
                }

                var userInputJson = JsonConvert.SerializeObject(userInput, Formatting.Indented);
                Console.WriteLine($"Received user input: {userInputJson}");

                // List of restricted roles (e.g., "System Administrator")
                var restrictedRoles = new List<string> { "System Administrator" };

                // ******To do ********** //
                // if account is just being created and role is restricted roles add account lockup enable

                // Handle roles if provided in the user input
                if (userInput.Roles != null && userInput.Roles.Any())
                {
                    Console.WriteLine("Processing roles...");
                    foreach (var roleObject in userInput.Roles)
                    {
                        if (roleObject == null || roleObject.Id == null)
                        {
                            Console.WriteLine($"Invalid Role object: {roleObject}");
                            return BadRequest(new { message = "Invalid Role object." });
                        }

                        var roleId = roleObject.Id;
                        Console.WriteLine($"Checking role with ID '{roleId}'...");

                        var roleFromDb = await _context.AspNetRoles
                            .FirstOrDefaultAsync(r => r.Id == roleId);

                        if (roleFromDb == null)
                        {
                            Console.WriteLine($"Role with ID '{roleId}' not found.");
                            return NotFound(new { message = $"Role with ID '{roleId}' not found." });
                        }

                        if (userInput.CompanyId.HasValue && restrictedRoles.Contains(roleFromDb.Name))
                        {
                            Console.WriteLine($"User has a CompanyId and role '{roleFromDb.Name}' is restricted. Terminating.");
                            return BadRequest(new { message = "Role NOT applicable for user!" });
                        }
                    }
                }
                else
                {
                    Console.WriteLine("No roles provided, skipping role logic.");
                }

                // Create an IdentityUser instance for UserManager only after role checks
                Console.WriteLine("Attempting to find user by ID...");
                var identityUser = await _userManager.FindByIdAsync(userInput.Id.ToString());
                if (identityUser == null)
                {
                    Console.WriteLine("User not found.");
                    return NotFound(new { message = "User not found." });
                }

                // Update the user properties
                Console.WriteLine("Updating user properties...");
                identityUser.UserName = userInput.UserName;
                identityUser.Email = userInput.Email;
                identityUser.PhoneNumber = userInput.PhoneNumber;

                // Password hashing, update only if provided
                if (!string.IsNullOrEmpty(userInput.PasswordHash))
                {
                    Console.WriteLine("Hashing password...");
                    var passwordHasher = new PasswordHasher<IdentityUser>();
                    identityUser.PasswordHash = passwordHasher.HashPassword(identityUser, userInput.PasswordHash);
                }

                // Update the user in the database
                Console.WriteLine("Attempting to update user in the database...");
                var updateResult = await _userManager.UpdateAsync(identityUser);
                if (!updateResult.Succeeded)
                {
                    Console.WriteLine($"User update failed: {string.Join(", ", updateResult.Errors.Select(e => e.Description))}");
                    return BadRequest(new { message = "Failed to update user.", errors = updateResult.Errors });
                }
                Console.WriteLine("User updated successfully.");

                // Handle roles after user is updated (only if roles are provided)
                if (userInput.Roles != null && userInput.Roles.Any())
                {
                    Console.WriteLine("Assigning roles...");
                    foreach (var roleObject in userInput.Roles)
                    {
                        var roleId = roleObject.Id;

                        var roleFromDb = await _context.AspNetRoles
                            .FirstOrDefaultAsync(r => r.Id == roleId);

                        if (roleFromDb != null)
                        {
                            var roleName = roleFromDb.Name;

                            if (userInput.CompanyId.HasValue && restrictedRoles.Contains(roleName))
                            {
                                Console.WriteLine($"User has a CompanyId and role '{roleName}' is restricted. Skipping assignment.");
                                continue;
                            }

                            var addRoleResult = await _userManager.AddToRoleAsync(identityUser, roleName);

                            if (!addRoleResult.Succeeded)
                            {
                                Console.WriteLine($"Role assignment failed for '{roleName}': {string.Join(", ", addRoleResult.Errors.Select(e => e.Description))}");
                                await _userManager.DeleteAsync(identityUser); // Optionally delete if role assignment fails
                                Console.WriteLine("User deleted due to role assignment failure.");
                                return BadRequest(new { message = "Failed to assign role." });
                            }

                            Console.WriteLine($"Role '{roleName}' assigned successfully.");
                        }
                    }
                }

                // Handle the company ID if provided
                if (userInput.CompanyId.HasValue)
                {
                    Console.WriteLine("Assigning CompanyId...");
                    var userFromDb = await _context.AspNetUsers
                        .FirstOrDefaultAsync(u => u.UserName == identityUser.UserName);

                    if (userFromDb != null)
                    {
                        userFromDb.CompanyId = userInput.CompanyId;
                        await _context.SaveChangesAsync();
                        Console.WriteLine($"Company Id '{userFromDb.CompanyId}' assigned successfully.");
                    }
                }



                return Json(new { success = true, Id = identityUser.Id, message = "Profile updated successfully." });

            }
            catch (Exception ex)
            {
                // Log the exception message and stack trace for debugging purposes
                Console.WriteLine($"An error occurred: {ex.Message}");
                Console.WriteLine($"Stack trace: {ex.StackTrace}");
                return StatusCode(500, new { message = "An internal server error occurred.", error = ex.Message });
            }
        }



        You're correct that there are several other events in DevExtreme's DataGrid, such as `onEditingPrepared`, `onEditingPreparing`, `onEditingCanceled`, and `onEditingCanceling`, which may be more appropriate depending on the specific behavior you want to achieve.

### Let's clarify the difference between `onEditingStart` and these other events:

1. **`onEditingStart`**:  
   - This event is triggered when the user starts editing a row. This is an ideal place to set up initial data or perform some validation before editing starts. 
   - However, it may not be the best place to modify data dynamically like `NormalizedUserName` or `NormalizedEmail`, since the user is already interacting with the grid.
   
2. **`onEditingPrepared`**:  
   - This event is triggered after the editor for a particular cell is prepared. This might be a good place to adjust the value of `NormalizedUserName` or `NormalizedEmail` dynamically as the user interacts with the editor, but not yet after the user submits the edit.

3. **`onEditingPreparing`**:  
   - This event occurs before the row enters the edit mode, allowing you to modify or prevent the edit action. It can be used for validating or altering the initial values right before the editor opens, but it’s not typically used for dynamically adjusting data as in your scenario.

4. **`onEditingCanceled` / `onEditingCanceling`**:
   - These events are triggered when the editing operation is canceled, either because the user pressed cancel or the operation was programmatically canceled. They are not relevant for your use case, as they happen after the user exits editing.

### So, what's the right choice here?

**`onEditingPrepared`** might be the most appropriate event in this scenario to dynamically update the `NormalizedUserName` and `NormalizedEmail` values as the user begins editing. This event fires after the editor is prepared, but before the user starts editing, which means you can modify the values before the editing process is fully activated.

### Updated Approach using `onEditingPrepared`:

```html
<script>
    // Update NormalizedUserName and NormalizedEmail when editing starts
    $("#gv_userList").dxDataGrid({
        onEditingPrepared: function (e) {
            // Ensure the NormalizedUserName is updated when UserName is changed
            if (e.column.dataField === "UserName" && e.value) {
                e.component.cellValue(e.rowIndex, "NormalizedUserName", e.value.toUpperCase());
            }
            // Ensure the NormalizedEmail is updated when Email is changed
            if (e.column.dataField === "Email" && e.value) {
                e.component.cellValue(e.rowIndex, "NormalizedEmail", e.value.toUpperCase());
            }
        }
    });
</script>
```

### Explanation of this approach:

- **`onEditingPrepared`**:
   - This event is fired right after the editor is initialized but before the user starts editing the cell. This is the perfect moment to manipulate or initialize any data before the user interacts with the grid.
   - We check if the column being edited is `UserName` or `Email`, and then we use `e.component.cellValue` to set the value for the corresponding `NormalizedUserName` or `NormalizedEmail` columns (which are hidden from the user).

### Why is this approach better?

- **Non-intrusive**: You don't have to rely on user actions to update the `NormalizedUserName` and `NormalizedEmail` values after they start editing. Instead, the values are updated right when the editor is ready.
- **Avoids unnecessary user interaction**: The user doesn't have to perform additional actions to ensure `NormalizedUserName` and `NormalizedEmail` are updated, which improves the user experience.

This should be a cleaner, more appropriate approach for updating these fields without involving the user directly in the process.


// Retrieve subscription logs associated with the user
                var subscriptionLogs = await _dbContext.SubscriptionLogs.Where(s => s.UserId == decodedUserId).ToListAsync();

                // Attach the logs to the user model
                user.SubscriptionLogs = subscriptionLogs;


.Lookup(lookup => lookup
.DataSource(ds => ds.Mvc()
.Controller("TreeListTasks")
.LoadAction("TaskEmployees")
.Key("ID")
)
.ValueExpr("ID")
.DisplayExpr("Name")
);




The issue you're encountering—getting a **bad request** due to 2FA being required—means that the `PasswordSignInAsync` method is detecting that the user has 2FA enabled but you're not handling the 2FA verification properly in your code.

When `PasswordSignInAsync` detects that the user has 2FA enabled, it returns a result indicating that the user needs to complete a 2FA check (typically `SignInResult.RequiresTwoFactor`). You need to catch this result and handle the 2FA process accordingly.

Here's a breakdown of what needs to be done:

1. **Detect the 2FA Requirement**: After attempting to sign in with `PasswordSignInAsync`, if 2FA is required, the result will indicate that, and you need to redirect the user to a 2FA verification page.

2. **Handle 2FA Verification**: If 2FA is enabled, you need to prompt the user for a 2FA code (either via email or SMS), and then verify that the code matches the one sent to the user.

3. **Return Response Based on 2FA**: If the 2FA verification is successful, proceed with the login process, otherwise return a failure message.

### Updated Code with 2FA Handling

Here's how you can modify your `LoginCheck` action to handle 2FA:

```csharp
[HttpGet]
public async Task<ActionResult> LoginCheck(string email, string password)
{
    // Log the start of the login attempt
    Console.WriteLine($"Login attempt started for email: {email}");

    // Find user by email
    var user = await _userManager.FindByEmailAsync(email);
    if (user == null)
    {
        // Log when the user is not found
        Console.WriteLine($"User not found for email: {email}");
        return BadRequest(new { success = false, mresponse = "User not found" });
    }

    // Log when the user is found
    Console.WriteLine($"User found for email: {email}");

    // Attempt login
    var result = await _signInManager.PasswordSignInAsync(user, password, isPersistent: false, lockoutOnFailure: false);

    if (result.Succeeded)
    {
        // Log successful login
        Console.WriteLine("Login successful.");

        // Check if the user needs 2FA verification
        if (await _userManager.GetTwoFactorEnabledAsync(user))
        {
            // If 2FA is required, check the user's preferred method (SMS or Email)
            var preferred2FAMethod = user.Preferred2FAMethod;

            // Send 2FA code based on preferred method
            if (preferred2FAMethod == "SMS")
            {
                var code = await _userManager.GenerateTwoFactorTokenAsync(user, "Phone");
                await _smsService.SendSmsAsync(user.PhoneNumber, code); // Implement SMS service
                Console.WriteLine("2FA code sent via SMS.");
            }
            else if (preferred2FAMethod == "Email")
            {
                var code = await _userManager.GenerateTwoFactorTokenAsync(user, "Email");
                await _emailService.SendEmailAsync(user.Email, "Your 2FA Code", code); // Implement Email service
                Console.WriteLine("2FA code sent via Email.");
            }

            // Return a response indicating the user should enter their 2FA code
            return Ok(new { success = true, mresponse = "2FA code sent", requires2FA = true });
        }

        // If no 2FA required, continue processing roles and redirect
        var roles = await _userManager.GetRolesAsync(user);

        var aspNetUser = await _dbContext.Set<AspNetUser>().FirstOrDefaultAsync(u => u.Email == email);

        if (roles.Contains("System Administrator"))
        {
            if (aspNetUser == null)
            {
                // Log when the user is not found in the custom table
                Console.WriteLine($"Custom user not found for email: {email}");
                return BadRequest(new { success = false, mresponse = "User not found." });
            }

            // Log the found AspNetUser
            Console.WriteLine($"Custom user found with CompanyId: {aspNetUser.Id}");

            var userId = aspNetUser.Id;

            if (userId != null)
            {
                // Encode the User Id using HashingHelper
                var encodedUserId = HashingHelper.EncodeString(userId);

                // Log the encoded CompanyId
                Console.WriteLine($"Encoded UserId: {encodedUserId}");

                // Construct the redirect URL
                var redirectUrl = $"/CoreSystem/SystemManager/Index/{encodedUserId}";

                // Return the response with the redirect URL
                return Ok(new { success = true, mresponse = "Login successful", redirectUrl });
            }
        }
        else if (roles.Contains("Company Administrator"))
        {
            if (aspNetUser == null)
            {
                // Log when the user is not found in the custom table
                Console.WriteLine($"Custom user not found for email: {email}");
                return BadRequest(new { success = false, mresponse = "User not found." });
            }

            // Log the found AspNetUser
            Console.WriteLine($"Custom user found with CompanyId: {aspNetUser.CompanyId}");

            var companyId = aspNetUser.CompanyId;

            if (companyId != null)
            {
                // Encode the CompanyId using HashingHelper
                var encodedCompanyId = HashingHelper.EncodeGuidID(companyId.Value);

                // Log the encoded CompanyId
                Console.WriteLine($"Encoded CompanyId: {encodedCompanyId}");

                // Construct the redirect URL
                var redirectUrl = $"/NutritionCompanySystem/NutritionSystem/Index/{encodedCompanyId}";

                // Return the response with the redirect URL
                return Ok(new { success = true, mresponse = "Login successful", redirectUrl });
            }
        }
        else
        {
            // Log when the user is neither a System Administrator nor a Company Administrator
            Console.WriteLine("User is neither a System Administrator nor a Company Administrator.");
            return Ok(new { success = true, mresponse = "Login successful" });
        }
    }

    // Log for failed login attempt
    Console.WriteLine("Invalid login attempt for email: " + email);
    return BadRequest(new { success = false, mresponse = "Invalid login attempt" });
}
```

### Key Changes:
1. **Checking if 2FA is enabled**: After a successful password sign-in, we check if the user has 2FA enabled using `await _userManager.GetTwoFactorEnabledAsync(user)`.
2. **Sending the 2FA code**: Based on the user's preferred 2FA method (SMS or email), we send the code using the appropriate service (SMS or email).
3. **Handling the 2FA Requirement**: If 2FA is enabled, we return a response indicating that the 2FA code has been sent and the user needs to provide it.
4. **Redirecting after successful login**: If no 2FA is required, the code proceeds to process roles and redirect the user to the appropriate page.

### Next Steps:
1. **2FA Code Verification**: You'll need an additional endpoint that verifies the 2FA code once the user enters it.
   
   For example:

   ```csharp
   [HttpPost]
   public async Task<IActionResult> Verify2FA(string email, string code)
   {
       var user = await _userManager.FindByEmailAsync(email);
       if (user == null)
       {
           return BadRequest(new { success = false, mresponse = "User not found" });
       }

       // Check if the user has 2FA enabled and verify the code
       var is2FACodeValid = await _userManager.VerifyTwoFactorTokenAsync(user, "Phone", code); // or "Email"
       if (is2FACodeValid)
       {
           await _signInManager.SignInAsync(user, isPersistent: false);
           return Ok(new { success = true, mresponse = "2FA successful, logged in." });
       }

       return BadRequest(new { success = false, mresponse = "Invalid 2FA code" });
   }
   ```

2. **User Interface**: You'll need to implement a UI where the user can input the 2FA code (sent via email or SMS) after login.


[ApiController]
[Route("api/[controller]/[action]")]
public class LoginAPIController : ControllerBase
{
    private readonly UserManager<IdentityUser> _userManager;
    private readonly SignInManager<IdentityUser> _signInManager;
    private readonly MedisatErpDbContext _dbContext;

    public LoginAPIController(UserManager<IdentityUser> userManager, SignInManager<IdentityUser> signInManager, MedisatErpDbContext dbContext)
    {
        _userManager = userManager;
        _signInManager = signInManager;
        _dbContext = dbContext;
    }

    [HttpGet]
    public async Task<ActionResult> LoginCheck(string email, string password)
    {
        // Log the start of the login attempt
        Console.WriteLine($"Login attempt started for email: {email}");

        // Find user by email
        var user = await _userManager.FindByEmailAsync(email);
        if (user == null)
        {
            // Log when the user is not found
            Console.WriteLine($"User not found for email: {email}");
            return BadRequest(new { success = false, mresponse = "User not found" });
        }

        // Log when the user is found
        Console.WriteLine($"User found for email: {email}");

        // Attempt login
        var result = await _signInManager.PasswordSignInAsync(user, password, isPersistent: false, lockoutOnFailure: false);

        if (result.Succeeded)
        {
            // Log successful login
            Console.WriteLine("Login successful.");

            // Get the roles of the user
            var roles = await _userManager.GetRolesAsync(user);

            // Retrieve the custom AspNetUser
            var aspNetUser = await _dbContext.Set<AspNetUser>().FirstOrDefaultAsync(u => u.Email == email);     

            if (roles.Contains("System Administrator"))
            {
                if (aspNetUser == null)
                {
                    // Log when the user is not found in the custom table
                    Console.WriteLine($"Custom user not found for email: {email}");
                    return BadRequest(new { success = false, mresponse = "User not found." });
                }

                // Log the found AspNetUser
                Console.WriteLine($"Custom user found with CompanyId: {aspNetUser.Id}");

                var userId = aspNetUser.Id;

                if(userId != null)
                {
                    // Encode the User Id using HashingHelper
                    var encodedUserId = HashingHelper.EncodeString(userId);

                    // Log the encoded CompanyId
                    Console.WriteLine($"Encoded UserId: {encodedUserId}");

                    // Construct the redirect URL
                    var redirectUrl = $"/2FA/Index/{encodedUserId}";

                    // Return the response with the redirect URL
                    return Ok(new { success = true, mresponse = "Login successful", redirectUrl });
                }

              
            }
            else if (roles.Contains("Company Administrator"))
            {
                

                if (aspNetUser == null)
                {
                    // Log when the user is not found in the custom table
                    Console.WriteLine($"Custom user not found for email: {email}");
                    return BadRequest(new { success = false, mresponse = "User not found." });
                }

                // Log the found AspNetUser
                Console.WriteLine($"Custom user found with CompanyId: {aspNetUser.CompanyId}");

                var companyId = aspNetUser.CompanyId;

                if (companyId != null)
                {
                    // Encode the CompanyId using HashingHelper
                    var encodedCompanyId = HashingHelper.EncodeGuidID(companyId.Value);

                    // Log the encoded CompanyId
                    Console.WriteLine($"Encoded CompanyId: {encodedCompanyId}");

                    // Construct the redirect URL
                    var redirectUrl = $"/NutritionCompanySystem/NutritionSystem/Index/{encodedCompanyId}";

                    // Return the response with the redirect URL
                    return Ok(new { success = true, mresponse = "Login successful", redirectUrl });
                }
            }
            else
            {
                // Log when the user is neither a System Administrator nor a Company Administrator
                Console.WriteLine("User is neither a System Administrator nor a Company Administrator.");
                return Ok(new { success = true, mresponse = "Login successful" });
            }
        }

        // Log for failed login attempt
        Console.WriteLine("Invalid login attempt for email: " + email);
        return BadRequest(new { success = false, mresponse = "Invalid login attempt" });
    }

}



    //[HttpGet]
    //public async Task<ActionResult> LoginCheck(string email, string password)
    //{
    //    // Validate the input parameters
    //    if (string.IsNullOrEmpty(email) || string.IsNullOrEmpty(password))
    //    {
    //        Console.WriteLine("Login attempt failed: email or password is empty");
    //        return BadRequest(new { success = false, mresponse = "Email and password are required" });
    //    }

    //    Console.WriteLine($"Login attempt started for email: {email}");

    //    try
    //    {
    //        var user = await _userManager.FindByEmailAsync(email);
    //        if (user == null)
    //        {
    //            Console.WriteLine($"User not found for email: {email}");
    //            return BadRequest(new { success = false, mresponse = "Invalid login attempt" });
    //        }

    //        Console.WriteLine($"User found for email: {email}");

    //        var result = await _signInManager.CheckPasswordSignInAsync(user, password, lockoutOnFailure: false);

    //        if (result.Succeeded)
    //        {
    //            Console.WriteLine($"Login successful for email: {email}");

    //            // Check if the user has TwoFactorAuthentication enabled
    //            if (user.TwoFactorEnabled)
    //            {

    //                // Log the redirection to 2FA
    //                Console.WriteLine($"Two-factor authentication is enabled for email: {email}. Redirecting to 2FA.");

    //                await _signInManager.SignOutAsync();
    //                await _signInManager.PasswordSignInAsync(user, password, isPersistent: false, lockoutOnFailure: false);

    //                // Encode user ID for redirection
    //                var encodedUserId = HashingHelper.EncodeString(user.Id);
    //                var redirectUrl = $"/TwoFA/Index/{encodedUserId}";

    //                return Ok(new { success = true, mresponse = "Login successful", redirectUrl });
    //            }

    //            // If 2FA is not enabled, proceed with login directly
    //            return Ok(new { success = true, mresponse = "Login successful" });
    //        }
    //        else if (result.IsLockedOut)
    //        {
    //            return BadRequest(new { success = false, mresponse = "Account is locked out" });
    //        }
    //        else
    //        {
    //            return BadRequest(new { success = false, mresponse = "Invalid login attempt" });
    //        }
    //    }
    //    catch (Exception ex)
    //    {
    //        Console.WriteLine($"Error: {ex.Message}");
    //        return StatusCode(500, new { success = false, mresponse = "An error occurred" });
    //    }
    //}


    [HttpGet]
    public async Task<ActionResult> LoginCheck(string email, string password)
    {
        // Validate the input parameters
        if (string.IsNullOrEmpty(email) || string.IsNullOrEmpty(password))
        {
            Console.WriteLine("Login attempt failed: email or password is empty");
            return BadRequest(new { success = false, mresponse = "Email and password are required" });
        }

        Console.WriteLine($"Login attempt started for email: {email}");

        try
        {
            // Try to find the user by email
            var user = await _userManager.FindByEmailAsync(email);
            if (user == null)
            {
                Console.WriteLine($"User not found for email: {email}");
                return BadRequest(new { success = false, mresponse = "Invalid login attempt" });
            }

            Console.WriteLine($"User found for email: {email}");

            // Attempt to sign in with the provided password
            var result = await _signInManager.PasswordSignInAsync(user, password, false, lockoutOnFailure: false);

            // Log the result of the login attempt
            Console.WriteLine($"PasswordSignInAsync result: RequiresTwoFactor = {result.RequiresTwoFactor}, Succeeded = {result.Succeeded}, IsLockedOut = {result.IsLockedOut}");

            string encodedUserId = null;  // Initialize encodedUserId as string
            string redirectUrl = null;    // Initialize redirectUrl as string

            // Handle users who require two-factor authentication
            if (result.RequiresTwoFactor)
            {
                Console.WriteLine("Two-factor authentication is required.");

                // Check if the `TwoFactorRememberBrowser` cookie is present
                if (await _signInManager.IsTwoFactorClientRememberedAsync(user))
                {
                    // Use RoleRedirectService to handle role-based redirection
                    var roleRedirectResult = await _roleRedirectService.HandleRoleRedirectAsync(email);
                    return roleRedirectResult;  // Return the redirect result

                }

                // Redirect to 2FA if the cookie is not present
                encodedUserId = HashingHelper.EncodeString(user.Id);
                redirectUrl = $"/TwoFA/Index/{encodedUserId}";
                return Ok(new { success = true, mresponse = "Login successful", redirectUrl });
            }

            // Handle users who don't require 2FA (persistent cookie exists)
            else if (result.Succeeded)
            {
                // Use RoleRedirectService to handle role-based redirection
                var roleRedirectResult = await _roleRedirectService.HandleRoleRedirectAsync(email);
                return roleRedirectResult;  // Return the redirect result
            }

            // Handle locked-out accounts
            else if (result.IsLockedOut)
            {

                return BadRequest(new { success = false, mresponse = "Account is locked out" });
            }
            else
            {
                return BadRequest(new { success = false, mresponse = "Invalid login attempt" });
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
            return StatusCode(500, new { success = false, mresponse = "An error occurred" });
        }
    }

     [HttpGet]
    public async Task<ActionResult> LoginCheck(string email, string password)
    {
        // Validate the input parameters
        if (string.IsNullOrEmpty(email) || string.IsNullOrEmpty(password))
        {
            Console.WriteLine("Login attempt failed: email or password is empty");
            return BadRequest(new { success = false, mresponse = "Email and password are required" });
        }

        Console.WriteLine($"Login attempt started for email: {email}");

        try
        {
            // Try to find the user by email
            var user = await _userManager.FindByEmailAsync(email);
            if (user == null)
            {
                Console.WriteLine($"User not found for email: {email}");
                return BadRequest(new { success = false, mresponse = "Invalid login attempt" });
            }

            if (await _userManager.IsEmailConfirmedAsync(user))
            { 
                

            
            }

            Console.WriteLine($"User found for email: {email}");

            // Attempt to sign in with the provided password
            var result = await _signInManager.PasswordSignInAsync(user, password, false, lockoutOnFailure: true);

            // Log the result of the login attempt
            Console.WriteLine($"PasswordSignInAsync result: RequiresTwoFactor = {result.RequiresTwoFactor}, Succeeded = {result.Succeeded}, IsLockedOut = {result.IsLockedOut}");

            string encodedUserId = null;  // Initialize encodedUserId as string
            string redirectUrl = null;    // Initialize redirectUrl as string

            // Handle users who require two-factor authentication
            if (result.RequiresTwoFactor)
            {
                Console.WriteLine("Two-factor authentication is required.");

                // Check if the `TwoFactorRememberBrowser` cookie is present
                if (await _signInManager.IsTwoFactorClientRememberedAsync(user))
                {
                    // Use RoleRedirectService to handle role-based redirection
                    var roleRedirectResult = await _roleRedirectService.HandleRoleRedirectAsync(email);
                    return roleRedirectResult;  // Return the redirect result
                }

                // Redirect to 2FA if the cookie is not present
                encodedUserId = HashingHelper.EncodeString(user.Id);
                redirectUrl = $"/TwoFA/Index/{encodedUserId}";
                return Ok(new { success = true, mresponse = "Login successful", redirectUrl });
            }

            // Handle users who don't require 2FA (persistent cookie exists)
            else if (result.Succeeded)
            {
                // Use RoleRedirectService to handle role-based redirection
                var roleRedirectResult = await _roleRedirectService.HandleRoleRedirectAsync(email);
                return roleRedirectResult;  // Return the redirect result
            }

            // Handle locked-out accounts
            else if (result.IsLockedOut)
            {
                // Log the lockout event for debugging
                Console.WriteLine($"Account is locked out for email: {email} at {DateTime.Now}");

                // Get the lockout end date if available
                var lockoutEnd = await _userManager.GetLockoutEndDateAsync(user);
                var lockoutMessage = lockoutEnd.HasValue
                    ? $"Account is locked out until {lockoutEnd.Value.LocalDateTime}"
                    : "Account is locked out";

                // Log the lockout end date for debugging
                Console.WriteLine(lockoutMessage);

				await _emailSender.SendEmailAsync(user.Email, "Account LookedOut", $"{lockoutMessage}");

				return BadRequest(new { success = false, mresponse = lockoutMessage });
            }
            else
            {
                return BadRequest(new { success = false, mresponse = "Invalid login attempt" });
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
            return StatusCode(500, new { success = false, mresponse = "An error occurred" });
        }
    }


    using System;
using System.Collections.Generic;
using MedisatERP.Areas.CoreSystem.Models;
using MedisatERP.Areas.NutritionCompanySystem.Models;
using MedisatERP.Models;
using Microsoft.EntityFrameworkCore;

namespace MedisatERP.Data;

public partial class MedisatErpDbContext : DbContext
{
    public MedisatErpDbContext()
    {
    }

    public MedisatErpDbContext(DbContextOptions<MedisatErpDbContext> options)
        : base(options)
    {
    }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        if (!optionsBuilder.IsConfigured)
        {
            var configuration = new ConfigurationBuilder()
                .SetBasePath(AppDomain.CurrentDomain.BaseDirectory)
                .AddJsonFile("appsettings.json")
                .Build();

            var connectionString = configuration.GetConnectionString("MedisatConnection");
            optionsBuilder.UseSqlServer(connectionString);
        }
    }

    public virtual DbSet<AspNetRole> AspNetRoles { get; set; }

    public virtual DbSet<AspNetUserRoles> AspNetUserRoles { get; set; }

    public virtual DbSet<AspNetRoleClaim> AspNetRoleClaims { get; set; }

    public virtual DbSet<AspNetUser> AspNetUsers { get; set; }

    public virtual DbSet<AspNetUserClaim> AspNetUserClaims { get; set; }

    public virtual DbSet<AspNetUserLogin> AspNetUserLogins { get; set; }

    public virtual DbSet<AspNetUserToken> AspNetUserTokens { get; set; }

    public virtual DbSet<AuditLog> AuditLogs { get; set; }

    public virtual DbSet<ClientAddress> ClientAddresses { get; set; }

    public virtual DbSet<Company> Companies { get; set; }

    public virtual DbSet<CompanyStatusLookup> CompanyStatusLookup { get; set; }

    public virtual DbSet<CompanyAddress> CompanyAddresses { get; set; }

    public virtual DbSet<CompanyClient> CompanyClients { get; set; }

    public virtual DbSet<DataMigration> DataMigrations { get; set; }

    public virtual DbSet<Feedback> Feedbacks { get; set; }

    public virtual DbSet<Allergy> Allergies { get; set; }

    public virtual DbSet<DietPlan> DietPlans { get; set; }

    public virtual DbSet<FoodDatabase> FoodDatabases { get; set; }

    public virtual DbSet<MealLogging> MealLoggings { get; set; }

    public virtual DbSet<MealPlan> MealPlans { get; set; }

    public virtual DbSet<MedicalCondition> MedicalConditions { get; set; }

    public virtual DbSet<NutritionalProfile> NutritionalProfiles { get; set; }

    public virtual DbSet<Report> Reports { get; set; }

    public virtual DbSet<BillingCycleLookup> BillingCycleLookups { get; set; }

    public virtual DbSet<Payment> Payments { get; set; }

    public virtual DbSet<PaymentMethodLookup> PaymentMethodLookups { get; set; }

    public virtual DbSet<PaymentStatusLookup> PaymentStatusLookups { get; set; }

    public virtual DbSet<Subscription> Subscriptions { get; set; }

    public virtual DbSet<SubscriptionActivityLookup> SubscriptionActivityLookups { get; set; }

    public virtual DbSet<SubscriptionLog> SubscriptionLogs { get; set; }

    public virtual DbSet<SubscriptionPlan> SubscriptionPlans { get; set; }

    public virtual DbSet<SubscriptionPlanNameLookup> SubscriptionPlanNameLookups { get; set; }

    public virtual DbSet<TrialNotification> TrialNotifications { get; set; }

    public virtual DbSet<TrialNotificationLookup> TrialNotificationLookups { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        => optionsBuilder.UseSqlServer("Data Source=medisaterp.lyfexafrica.com;uid=adminMedisatERP;pwd=Planchinobo256;TrustServerCertificate=True;");

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<AspNetRole>(entity =>
        {
            entity.HasIndex(e => e.NormalizedName, "RoleNameIndex")
                .IsUnique()
                .HasFilter("([NormalizedName] IS NOT NULL)");

            entity.Property(e => e.Name).HasMaxLength(256);
            entity.Property(e => e.NormalizedName).HasMaxLength(256);
        });

        modelBuilder.Entity<AspNetUserRoles>(entity =>
        {
            entity.HasKey(ur => new { ur.UserId, ur.RoleId });

            entity.HasOne(ur => ur.User)
                .WithMany(u => u.AspNetUserRoles)
                .HasForeignKey(ur => ur.UserId);

            entity.HasOne(ur => ur.Role)
                .WithMany(r => r.AspNetUserRoles)
                .HasForeignKey(ur => ur.RoleId);
        });

        modelBuilder.Entity<AspNetRoleClaim>(entity =>
        {
            entity.HasIndex(e => e.RoleId, "IX_AspNetRoleClaims_RoleId");

            entity.Property(e => e.RoleId).IsRequired();

            entity.HasOne(d => d.Role).WithMany(p => p.AspNetRoleClaims).HasForeignKey(d => d.RoleId);
        });

        // Configure relationships
        modelBuilder.Entity<AspNetUser>(entity =>
        {
            entity.HasIndex(e => e.NormalizedEmail).HasDatabaseName("EmailIndex");

            entity.HasIndex(e => e.NormalizedUserName).HasDatabaseName("UserNameIndex")
                .IsUnique()
                .HasFilter("[NormalizedUserName] IS NOT NULL");

            entity.Property(e => e.Email).HasMaxLength(256);
            entity.Property(e => e.NormalizedEmail).HasMaxLength(256);
            entity.Property(e => e.NormalizedUserName).HasMaxLength(256);
            entity.Property(e => e.UserName).HasMaxLength(256);

            // Add the CompanyId property and configure the relationship
            entity.Property(e => e.CompanyId).IsRequired(false);

            entity.HasOne(d => d.Company)
                .WithMany(p => p.Users)
                .HasForeignKey(d => d.CompanyId)
                .OnDelete(DeleteBehavior.Restrict);

            // Configure the new ProfileImagePath property
            entity.Property(e => e.ProfileImagePath)
                .HasMaxLength(255)
                .IsRequired(false);

            // Configure the new BioData property
            entity.Property(e => e.BioData)
                .HasMaxLength(500)  // Adjust the max length as needed
                .IsRequired(false);
        });

        modelBuilder.Entity<AspNetUserClaim>(entity =>
        {
            entity.HasIndex(e => e.UserId, "IX_AspNetUserClaims_UserId");

            entity.Property(e => e.UserId).IsRequired();

            entity.HasOne(d => d.User).WithMany(p => p.AspNetUserClaims).HasForeignKey(d => d.UserId);
        });

        modelBuilder.Entity<AspNetUserLogin>(entity =>
        {
            entity.HasKey(e => new { e.LoginProvider, e.ProviderKey });

            entity.HasIndex(e => e.UserId, "IX_AspNetUserLogins_UserId");

            entity.Property(e => e.UserId).IsRequired();

            entity.HasOne(d => d.User).WithMany(p => p.AspNetUserLogins).HasForeignKey(d => d.UserId);
        });

        modelBuilder.Entity<AspNetUserToken>(entity =>
        {
            entity.HasKey(e => new { e.UserId, e.LoginProvider, e.Name });

            entity.HasOne(d => d.User).WithMany(p => p.AspNetUserTokens).HasForeignKey(d => d.UserId);
        });

        modelBuilder.Entity<AuditLog>(entity =>
        {
            entity.HasKey(e => e.AuditLogId).HasName("PK__AuditLog__EB5F6CBD75CDDDCB");

            entity.Property(e => e.AuditLogId).HasDefaultValueSql("(newid())");
            entity.Property(e => e.Action)
                .IsRequired()
                .HasMaxLength(256);
            entity.Property(e => e.CompanyId).HasDefaultValueSql("(newid())");
            entity.Property(e => e.ComplianceStatus).HasMaxLength(100);
            entity.Property(e => e.DeviceInfo).HasMaxLength(512);
            entity.Property(e => e.EntityAffected)
                .IsRequired()
                .HasMaxLength(100);
            entity.Property(e => e.EventType)
                .IsRequired()
                .HasMaxLength(100);
            entity.Property(e => e.IpAddress).HasMaxLength(45);
            entity.Property(e => e.Timestamp)
                .HasDefaultValueSql("(getdate())")
                .HasColumnType("datetime");
            entity.Property(e => e.UserId)
                .IsRequired()
                .HasMaxLength(450);

            entity.HasOne(d => d.Company).WithMany(p => p.AuditLogs)
                .HasForeignKey(d => d.CompanyId)
                .HasConstraintName("FK_AuditLogs_Company");

            entity.HasOne(d => d.User).WithMany(p => p.AuditLogs)
                .HasForeignKey(d => d.UserId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__AuditLogs__UserI__0D7A0286");
        });

        modelBuilder.Entity<ClientAddress>(entity =>
        {
            entity.HasKey(e => e.AddressId);

            entity.ToTable("ClientAddress");

            entity.Property(e => e.AddressId).ValueGeneratedNever();
            entity.Property(e => e.City)
                .IsRequired()
                .HasMaxLength(100);
            entity.Property(e => e.Country)
                .IsRequired()
                .HasMaxLength(100);
            entity.Property(e => e.PostalCode).HasMaxLength(20);
            entity.Property(e => e.State).HasMaxLength(100);
            entity.Property(e => e.Street)
                .IsRequired()
                .HasMaxLength(256);
        });

        modelBuilder.Entity<Company>(entity =>
        {
            entity.Property(e => e.CompanyId).ValueGeneratedNever();
            entity.Property(e => e.ApiCode).HasMaxLength(256);
            entity.Property(e => e.CompanyEmail).HasMaxLength(256);
            entity.Property(e => e.CompanyInitials).HasMaxLength(10);
            entity.Property(e => e.CompanyLogoFilePath).HasMaxLength(512);
            entity.Property(e => e.CompanyName).HasMaxLength(256);
            entity.Property(e => e.CompanyPhone).HasMaxLength(15);
            entity.Property(e => e.CompanyType).HasMaxLength(100);
            entity.Property(e => e.ContactPerson).HasMaxLength(256);
            entity.Property(e => e.CreatedAt).HasColumnType("datetime");
            entity.Property(e => e.Motto).HasMaxLength(512);

            entity.HasOne(d => d.CompanyStatus)  
            .WithMany(p => p.Companies)  
            .HasForeignKey(d => d.StatusId)  
            .HasConstraintName("FK_CompanyStatus"); 

            entity.HasOne(d => d.Address).WithMany(p => p.Companies)
                .HasForeignKey(d => d.AddressId)
                .HasConstraintName("FK_Companies_CompanyAddress");
        });

        modelBuilder.Entity<CompanyStatusLookup>(entity =>
        {
            entity.HasKey(e => e.StatusId)
                .HasName("PK__CompanyS__C8EE20635B13B506");
            entity.ToTable("CompanyStatusLookup", "dbo");
            entity.Property(e => e.StatusName)
                .IsRequired()  
                .HasMaxLength(50);  
            entity.HasMany(e => e.Companies)
                .WithOne(c => c.CompanyStatus) 
                .HasForeignKey(c => c.StatusId); 
        });

        modelBuilder.Entity<CompanyAddress>(entity =>
        {
            entity.HasKey(e => e.AddressId);

            entity.ToTable("CompanyAddress");

            entity.Property(e => e.AddressId).ValueGeneratedNever();
            entity.Property(e => e.City).HasMaxLength(100);
            entity.Property(e => e.Country).HasMaxLength(100);
            entity.Property(e => e.PostalCode).HasMaxLength(20);
            entity.Property(e => e.State).HasMaxLength(100);
            entity.Property(e => e.Street).HasMaxLength(256);
        });

        modelBuilder.Entity<CompanyClient>(entity =>
        {
            entity.HasKey(e => e.ClientId);

            entity.Property(e => e.ClientId).ValueGeneratedNever();
            entity.Property(e => e.ClientName)
                .IsRequired()
                .HasMaxLength(200);
            entity.Property(e => e.CreatedAt).HasColumnType("datetime");
            entity.Property(e => e.DateOfBirth).HasColumnType("datetime");
            entity.Property(e => e.Email)
                .IsRequired()
                .HasMaxLength(256);
            entity.Property(e => e.EmergencyContactName).HasMaxLength(256);
            entity.Property(e => e.EmergencyContactPhone).HasMaxLength(15);
            entity.Property(e => e.Gender)
                .IsRequired()
                .HasMaxLength(10);
            entity.Property(e => e.MaritalStatus)
                .IsRequired()
                .HasMaxLength(50);
            entity.Property(e => e.Nationality)
                .IsRequired()
                .HasMaxLength(100);
            entity.Property(e => e.PhoneNumber)
                .IsRequired()
                .HasMaxLength(15);
            entity.Property(e => e.UpdatedAt).HasColumnType("datetime");

            entity.HasOne(d => d.Address).WithMany(p => p.CompanyClients)
                .HasForeignKey(d => d.AddressId)
                .HasConstraintName("FK_Client_Address");

            entity.HasOne(d => d.Company).WithMany(p => p.CompanyClients)
                .HasForeignKey(d => d.CompanyId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK_Company_Client");
        });

        modelBuilder.Entity<DataMigration>(entity =>
        {
            entity.HasKey(e => e.MigrationId).HasName("PK__DataMigr__E5D3573B40556A31");

            entity.ToTable("DataMigration");

            entity.Property(e => e.MigrationId).ValueGeneratedNever();
            entity.Property(e => e.DestinationSystem)
                .IsRequired()
                .HasMaxLength(256);
            entity.Property(e => e.EndDate).HasColumnType("datetime");
            entity.Property(e => e.SourceSystem)
                .IsRequired()
                .HasMaxLength(256);
            entity.Property(e => e.StartDate).HasColumnType("datetime");
            entity.Property(e => e.Status)
                .IsRequired()
                .HasMaxLength(50);

            entity.HasOne(d => d.Company).WithMany(p => p.DataMigrations)
                .HasForeignKey(d => d.CompanyId)
                .HasConstraintName("FK_DataMigration_Company");
        });

        modelBuilder.Entity<Feedback>(entity =>
        {
            entity.HasKey(e => e.FeedbackId).HasName("PK__Feedback__6A4BEDD6D745BCAA");

            entity.ToTable("Feedback");

            entity.Property(e => e.FeedbackId).HasDefaultValueSql("(newid())");
            entity.Property(e => e.Category).HasMaxLength(100);
            entity.Property(e => e.CompanyId).HasDefaultValueSql("(newid())");
            entity.Property(e => e.FeedbackText).IsRequired();
            entity.Property(e => e.SubmittedAt)
                .HasDefaultValueSql("(getdate())")
                .HasColumnType("datetime");
            entity.Property(e => e.UserId)
                .IsRequired()
                .HasMaxLength(450);

            entity.HasOne(d => d.Company).WithMany(p => p.Feedbacks)
                .HasForeignKey(d => d.CompanyId)
                .HasConstraintName("FK_Feedback_Company");

            entity.HasOne(d => d.User).WithMany(p => p.Feedbacks)
                .HasForeignKey(d => d.UserId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__Feedback__UserId__08B54D69");
        });


        modelBuilder.Entity<Allergy>(entity =>
        {
            entity.HasKey(e => e.AllergyId).HasName("PK__Allergie__A49EBE42E4BFCC36");

            entity.ToTable("Allergies", "dbo");

            entity.Property(e => e.AllergyId).HasDefaultValueSql("(newid())");
            entity.Property(e => e.AllergyName)
                .IsRequired()
                .HasMaxLength(100)
                .IsUnicode(false);
            entity.Property(e => e.Severity)
                .HasMaxLength(50)
                .IsUnicode(false);

            entity.HasOne(d => d.Client).WithMany(p => p.Allergies)
                .HasForeignKey(d => d.ClientId)
                .HasConstraintName("FK__Allergies__Clien__55BFB948");
        });

        modelBuilder.Entity<CompanyClient>(entity =>
        {
            entity.HasKey(e => e.ClientId);

            entity.ToTable("CompanyClients", "dbo");

            entity.Property(e => e.ClientId).HasDefaultValueSql("(newid())");
            entity.Property(e => e.ClientName)
                .IsRequired()
                .HasMaxLength(200);
            entity.Property(e => e.CreatedAt)
                .HasDefaultValueSql("(getdate())")
                .HasColumnType("datetime");
            entity.Property(e => e.DateOfBirth).HasColumnType("datetime");
            entity.Property(e => e.Email)
                .IsRequired()
                .HasMaxLength(256);
            entity.Property(e => e.EmergencyContactName).HasMaxLength(256);
            entity.Property(e => e.EmergencyContactPhone).HasMaxLength(15);
            entity.Property(e => e.Gender)
                .IsRequired()
                .HasMaxLength(10);
            entity.Property(e => e.MaritalStatus)
                .IsRequired()
                .HasMaxLength(50);
            entity.Property(e => e.Nationality)
                .IsRequired()
                .HasMaxLength(100);
            entity.Property(e => e.PhoneNumber)
                .IsRequired()
                .HasMaxLength(15);
            entity.Property(e => e.UpdatedAt).HasColumnType("datetime");
        });

        modelBuilder.Entity<DietPlan>(entity =>
        {
            entity.HasKey(e => e.DietPlanId).HasName("PK__DietPlan__D256E10A3F13B2C9");

            entity.ToTable("DietPlan", "dbo");

            entity.Property(e => e.DietPlanId).HasDefaultValueSql("(newid())");
            entity.Property(e => e.CreatedBy)
                .IsRequired()
                .HasMaxLength(100)
                .IsUnicode(false);
            entity.Property(e => e.DietPlanName)
                .IsRequired()
                .HasMaxLength(100)
                .IsUnicode(false);
            entity.Property(e => e.EndDate).HasColumnType("date");
            entity.Property(e => e.LastUpdated).HasColumnType("datetime");
            entity.Property(e => e.StartDate).HasColumnType("date");

            entity.HasOne(d => d.Allergy).WithMany(p => p.DietPlans)
                .HasForeignKey(d => d.AllergyId)
                .HasConstraintName("FK__DietPlan__Allerg__7167D3BD");

            entity.HasOne(d => d.Client).WithMany(p => p.DietPlans)
                .HasForeignKey(d => d.ClientId)
                .HasConstraintName("FK__DietPlan__Client__7073AF84");
        });

        modelBuilder.Entity<FoodDatabase>(entity =>
        {
            entity.HasKey(e => e.FoodItemId).HasName("PK__FoodData__464DC8124C775F72");

            entity.ToTable("FoodDatabase", "dbo");

            entity.Property(e => e.FoodItemId).HasDefaultValueSql("(newid())");
            entity.Property(e => e.Category)
                .HasMaxLength(50)
                .IsUnicode(false);
            entity.Property(e => e.FoodName)
                .IsRequired()
                .HasMaxLength(100)
                .IsUnicode(false);

            entity.HasOne(d => d.Client).WithMany(p => p.FoodDatabases)
                .HasForeignKey(d => d.ClientId)
                .HasConstraintName("FK__FoodDatab__Carbs__0A338187");
        });

        modelBuilder.Entity<MealLogging>(entity =>
        {
            entity.HasKey(e => e.LogId).HasName("PK__MealLogg__5E548648CA2986E7");

            entity.ToTable("MealLogging", "dbo");

            entity.Property(e => e.LogId).HasDefaultValueSql("(newid())");
            entity.Property(e => e.LogDate).HasColumnType("datetime");

            entity.HasOne(d => d.Client).WithMany(p => p.MealLoggings)
                .HasForeignKey(d => d.ClientId)
                .HasConstraintName("FK__MealLoggi__Clien__15A53433");

            entity.HasOne(d => d.FoodItem).WithMany(p => p.MealLoggings)
                .HasForeignKey(d => d.FoodItemId)
                .HasConstraintName("FK__MealLoggi__FoodI__178D7CA5");
        });

        modelBuilder.Entity<MealPlan>(entity =>
        {
            entity.HasKey(e => e.MealPlanId).HasName("PK__MealPlan__0620DB7677F15438");

            entity.ToTable("MealPlans", "dbo");

            entity.Property(e => e.MealPlanId).HasDefaultValueSql("(newid())");
            entity.Property(e => e.FoodCategory)
                .HasMaxLength(50)
                .IsUnicode(false);
            entity.Property(e => e.MealName)
                .IsRequired()
                .HasMaxLength(100)
                .IsUnicode(false);

            entity.HasOne(d => d.DietPlan).WithMany(p => p.MealPlans)
                .HasForeignKey(d => d.DietPlanId)
                .HasConstraintName("FK__MealPlans__DietP__11D4A34F");
        });

        modelBuilder.Entity<MedicalCondition>(entity =>
        {
            entity.HasKey(e => e.ConditionId).HasName("PK__MedicalC__37F5C0CF98AE7599");

            entity.ToTable("MedicalConditions", "dbo");

            entity.Property(e => e.ConditionId).HasDefaultValueSql("(newid())");
            entity.Property(e => e.ConditionName)
                .IsRequired()
                .HasMaxLength(100)
                .IsUnicode(false);
            entity.Property(e => e.DiagnosisDate).HasColumnType("date");

            entity.HasOne(d => d.Client).WithMany(p => p.MedicalConditions)
                .HasForeignKey(d => d.ClientId)
                .HasConstraintName("FK__MedicalCo__Clien__59904A2C");
        });

        modelBuilder.Entity<NutritionalProfile>(entity =>
        {
            entity.HasKey(e => e.ProfileId).HasName("PK__Nutritio__290C88E46E0FE18E");

            entity.ToTable("NutritionalProfile", "dbo");

            entity.Property(e => e.ProfileId).HasDefaultValueSql("(newid())");
            entity.Property(e => e.Height)
                .HasColumnType("decimal(5, 2)")
                .HasColumnName("height");
            entity.Property(e => e.Weight)
                .HasColumnType("decimal(5, 2)")
                .HasColumnName("weight");

            entity.HasOne(d => d.Allergy).WithMany(p => p.NutritionalProfiles)
                .HasForeignKey(d => d.AllergyId)
                .HasConstraintName("FK__Nutrition__Aller__047AA831");

            entity.HasOne(d => d.Client).WithMany(p => p.NutritionalProfiles)
                .HasForeignKey(d => d.ClientId)
                .HasConstraintName("FK__Nutrition__Clien__038683F8");

            entity.HasOne(d => d.DietPlan).WithMany(p => p.NutritionalProfiles)
                .HasForeignKey(d => d.DietPlanId)
                .HasConstraintName("FK__Nutrition__DietP__0662F0A3");
        });

        modelBuilder.Entity<Report>(entity =>
        {
            entity.HasKey(e => e.ReportId).HasName("PK__Report__D5BD48054B37C2EE");

            entity.ToTable("Report", "dbo");

            entity.Property(e => e.ReportId).HasDefaultValueSql("(newid())");
            entity.Property(e => e.ReportContent).HasColumnType("text");
            entity.Property(e => e.ReportDate).HasColumnType("datetime");
            entity.Property(e => e.ReportType)
                .IsRequired()
                .HasMaxLength(100)
                .IsUnicode(false);

            entity.HasOne(d => d.Client).WithMany(p => p.Reports)
                .HasForeignKey(d => d.ClientId)
                .HasConstraintName("FK__Report__ClientId__6CA31EA0");
        });

        modelBuilder.Entity<BillingCycleLookup>(entity =>
        {
            entity.HasKey(e => e.Id).HasName("PK__BillingC__3214EC07271F0E00");

            entity.ToTable("BillingCycleLookup", "dbo");

            entity.Property(e => e.Id).ValueGeneratedNever();
            entity.Property(e => e.CycleName)
                .IsRequired()
                .HasMaxLength(50);
        });


        modelBuilder.Entity<Payment>(entity =>
        {
            entity.HasKey(e => e.Id).HasName("PK__Payment__3214EC072C033188");

            entity.ToTable("Payment", "dbo");

            entity.Property(e => e.Id).ValueGeneratedNever();
            entity.Property(e => e.PaymentDate).HasColumnType("datetime");
            entity.Property(e => e.TransactionId).HasMaxLength(255);

            entity.HasOne(d => d.PaymentMethod).WithMany(p => p.Payments)
                .HasForeignKey(d => d.PaymentMethodId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__Payment__Payment__60FC61CA");

            entity.HasOne(d => d.PaymentStatus).WithMany(p => p.Payments)
                .HasForeignKey(d => d.PaymentStatusId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__Payment__Payment__60083D91");

            entity.HasOne(d => d.Subscription).WithMany(p => p.Payments)
                .HasForeignKey(d => d.SubscriptionId)
                .OnDelete(DeleteBehavior.SetNull)
                .HasConstraintName("FK__Payment__Subscri__5F141958");
        });

        modelBuilder.Entity<PaymentMethodLookup>(entity =>
        {
            entity.HasKey(e => e.Id).HasName("PK__PaymentM__3214EC073CC5077C");

            entity.ToTable("PaymentMethodLookup", "dbo");

            entity.Property(e => e.Method)
                .IsRequired()
                .HasMaxLength(50);
        });

        modelBuilder.Entity<PaymentStatusLookup>(entity =>
        {
            entity.HasKey(e => e.Id).HasName("PK__PaymentS__3214EC07340D8E27");

            entity.ToTable("PaymentStatusLookup", "dbo");

            entity.Property(e => e.Status)
                .IsRequired()
                .HasMaxLength(50);
        });

        modelBuilder.Entity<Subscription>(entity =>
        {
            entity.HasKey(e => e.Id).HasName("PK__Subscrip__3214EC07EB97F597");

            entity.ToTable("Subscription", "dbo");

            entity.Property(e => e.Id).ValueGeneratedNever();
            entity.Property(e => e.EndDate).HasColumnType("datetime");
            entity.Property(e => e.PaymentStatus)
                .IsRequired()
                .HasMaxLength(50)
                .IsUnicode(false);
            entity.Property(e => e.StartDate).HasColumnType("datetime");

            entity.HasOne(d => d.Company).WithMany(p => p.Subscriptions)
                .HasForeignKey(d => d.CompanyId)
                .OnDelete(DeleteBehavior.SetNull)
                .HasConstraintName("FK_Company_Subscription");

            entity.HasOne(d => d.SubscriptionPlan).WithMany(p => p.Subscriptions)
                .HasForeignKey(d => d.SubscriptionPlanId)
                .HasConstraintName("FK_SubscriptionPlan_Subscription");
        });

        modelBuilder.Entity<SubscriptionActivityLookup>(entity =>
        {
            entity.HasKey(e => e.Id).HasName("PK__Subscrip__3214EC070751D0BB");

            entity.ToTable("SubscriptionActivityLookup", "dbo");

            entity.Property(e => e.ActivityName)
                .IsRequired()
                .HasMaxLength(255);
        });

        modelBuilder.Entity<SubscriptionLog>(entity =>
        {
            entity.HasKey(e => e.Id).HasName("PK__Subscrip__3214EC070EA444F0");

            entity.ToTable("SubscriptionLog", "dbo");

            entity.Property(e => e.Id).ValueGeneratedNever();
            entity.Property(e => e.LogDate).HasColumnType("datetime");

            entity.HasOne(d => d.Activity).WithMany(p => p.SubscriptionLogs)
                .HasForeignKey(d => d.ActivityId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK__Subscript__Activ__0539C240");

            entity.HasOne(d => d.Subscription).WithMany(p => p.SubscriptionLogs)
                .HasForeignKey(d => d.SubscriptionId)
                .HasConstraintName("FK__Subscript__Subsc__04459E07");
        });

        modelBuilder.Entity<SubscriptionPlan>(entity =>
        {
            entity.HasKey(e => e.Id).HasName("PK__Subscrip__3214EC077710149E");

            entity.ToTable("SubscriptionPlan", "dbo");

            entity.Property(e => e.Id).ValueGeneratedNever();
            entity.Property(e => e.Description).HasMaxLength(500);

            entity.HasOne(d => d.BillingCycle).WithMany(p => p.SubscriptionPlans)
                .HasForeignKey(d => d.BillingCycleId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK_BillingCycle_SubscriptionPlan");

            entity.HasOne(d => d.PlanName).WithMany(p => p.SubscriptionPlans)
                .HasForeignKey(d => d.PlanNameId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK_PlanName_SubscriptionPlan");
        });

        modelBuilder.Entity<SubscriptionPlanNameLookup>(entity =>
        {
            entity.HasKey(e => e.Id).HasName("PK__Subscrip__3214EC0726F9188B");

            entity.ToTable("SubscriptionPlanNameLookup", "dbo");

            entity.Property(e => e.Id).ValueGeneratedNever();
            entity.Property(e => e.PlanName)
                .IsRequired()
                .HasMaxLength(255);
            entity.Property(e => e.Price).HasColumnType("decimal(18, 2)");
        });

        modelBuilder.Entity<TrialNotification>(entity =>
        {
            entity.HasKey(e => e.Id).HasName("PK__TrialNot__3214EC07BD034B76");

            entity.ToTable("TrialNotification", "dbo");

            entity.Property(e => e.Id).ValueGeneratedNever();
            entity.Property(e => e.ReminderDate).HasColumnType("datetime");
            entity.Property(e => e.SentAt)
                .HasDefaultValueSql("(getdate())")
                .HasColumnType("datetime");
            entity.Property(e => e.TrialEndDate).HasColumnType("datetime");
            entity.Property(e => e.TrialStartDate).HasColumnType("datetime");

            entity.HasOne(d => d.Company).WithMany(p => p.TrialNotifications)
                .HasForeignKey(d => d.CompanyId)
                .OnDelete(DeleteBehavior.SetNull)
                .HasConstraintName("FK_Company_TrialNotification");

            entity.HasOne(d => d.NotificationType).WithMany(p => p.TrialNotifications)
                .HasForeignKey(d => d.NotificationTypeId)
                .OnDelete(DeleteBehavior.ClientSetNull)
                .HasConstraintName("FK_NotificationType_TrialNotification");
        });

        modelBuilder.Entity<TrialNotificationLookup>(entity =>
        {
            entity.HasKey(e => e.Id).HasName("PK__TrialNot__3214EC0794269932");

            entity.ToTable("TrialNotificationLookup", "dbo");

            entity.Property(e => e.Message)
                .IsRequired()
                .HasColumnType("text");
            entity.Property(e => e.Type)
                .IsRequired()
                .HasMaxLength(50)
                .IsUnicode(false);
        });

        OnModelCreatingPartial(modelBuilder);
    }

    partial void OnModelCreatingPartial(ModelBuilder modelBuilder);
}


Create online applicants page with approval or disapproval logic
Intergrate the API
Add lyfex logo in the Company system
Add reason on appointment page
Clients table update, make gender, nationality, country, maritial status dropdowns and add emergency person relationship, whatsapp no.
Solve delete error 
